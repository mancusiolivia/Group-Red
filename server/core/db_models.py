"""
SQLAlchemy ORM models matching the ERD schema
Compatible with Python 3.11+ (tested on 3.11 and 3.13)
"""
from sqlalchemy import Column, Integer, String, Text, Float, DateTime, ForeignKey, Index
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from datetime import datetime

from server.core.database import Base


def utc_now():
    """
    Get current UTC datetime, compatible with Python 3.11+
    Uses datetime.utcnow() for 3.11 compatibility (deprecated in 3.12+ but still works)
    """
    return datetime.utcnow()


class User(Base):
    """Users table for authentication"""
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    username = Column(String, nullable=False, unique=True)
    password = Column(String, nullable=False)  # Store plain text password (hard-coded for now)
    user_type = Column(String, nullable=False, default="student")  # 'student' or 'instructor'
    student_id = Column(Integer, ForeignKey("students.id"), nullable=True)
    instructor_id = Column(Integer, ForeignKey("instructors.id"), nullable=True)
    created_at = Column(DateTime, nullable=False, default=utc_now, server_default=func.now())
    
    # Relationships
    student = relationship("Student", foreign_keys=[student_id])
    instructor = relationship("Instructor", foreign_keys=[instructor_id])


class Instructor(Base):
    """Instructors table"""
    __tablename__ = "instructors"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    name = Column(String, nullable=False)
    email = Column(String, unique=True)
    domain_expertise = Column(Text)
    created_at = Column(DateTime, nullable=False, default=utc_now, server_default=func.now())
    
    # Relationships
    exams = relationship("Exam", back_populates="instructor")


class Student(Base):
    """Students table"""
    __tablename__ = "students"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    student_id = Column(String, nullable=False, unique=True)  # campus ID
    name = Column(String, nullable=False)
    email = Column(String)
    created_at = Column(DateTime, nullable=False, default=utc_now, server_default=func.now())
    
    # Relationships
    submissions = relationship("Submission", back_populates="student")


class Exam(Base):
    """Exams table"""
    __tablename__ = "exams"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    instructor_id = Column(Integer, ForeignKey("instructors.id"), nullable=False)
    domain = Column(String, nullable=False)  # e.g., "Cybersecurity", "Music Theory"
    title = Column(String)  # optional
    instructions_to_llm = Column(Text)  # professor-provided intent/constraints
    model_name = Column(String)  # which Together model used
    temperature = Column(Float)
    created_at = Column(DateTime, nullable=False, default=utc_now, server_default=func.now())
    
    # Relationships
    instructor = relationship("Instructor", back_populates="exams")
    questions = relationship("Question", back_populates="exam", cascade="all, delete-orphan")
    submissions = relationship("Submission", back_populates="exam", cascade="all, delete-orphan")


class Question(Base):
    """Questions table"""
    __tablename__ = "questions"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    exam_id = Column(Integer, ForeignKey("exams.id"), nullable=False)
    q_index = Column(Integer, nullable=False)  # 1..N ordering
    prompt = Column(Text, nullable=False)  # the question shown to student
    background_info = Column(Text)  # background information displayed to students
    model_answer = Column(Text)  # optional reference answer
    points_possible = Column(Float, nullable=False, default=1.0)
    created_at = Column(DateTime, nullable=False, default=utc_now, server_default=func.now())
    
    # Relationships
    exam = relationship("Exam", back_populates="questions")
    rubric = relationship("Rubric", back_populates="question", uselist=False, cascade="all, delete-orphan")
    answers = relationship("Answer", back_populates="question")
    
    # Indexes
    __table_args__ = (
        Index("idx_exam_q_index", "exam_id", "q_index", unique=True),
    )


class Rubric(Base):
    """Rubrics table"""
    __tablename__ = "rubrics"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    question_id = Column(Integer, ForeignKey("questions.id"), nullable=False, unique=True)
    rubric_text = Column(Text, nullable=False)  # generated by LLM
    created_at = Column(DateTime, nullable=False, default=utc_now, server_default=func.now())
    
    # Relationships
    question = relationship("Question", back_populates="rubric")


class Submission(Base):
    """Submissions table"""
    __tablename__ = "submissions"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    exam_id = Column(Integer, ForeignKey("exams.id"), nullable=False)
    student_id = Column(Integer, ForeignKey("students.id"), nullable=False)
    started_at = Column(DateTime, nullable=False, default=datetime.utcnow, server_default=func.now())
    submitted_at = Column(DateTime)  # nullable until submitted
    
    # Relationships
    exam = relationship("Exam", back_populates="submissions")
    student = relationship("Student", back_populates="submissions")
    answers = relationship("Answer", back_populates="submission", cascade="all, delete-orphan")
    
    # Indexes
    __table_args__ = (
        Index("idx_submission_exam_student_started", "exam_id", "student_id", "started_at"),
    )


class Answer(Base):
    """Answers table"""
    __tablename__ = "answers"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    submission_id = Column(Integer, ForeignKey("submissions.id"), nullable=False)
    question_id = Column(Integer, ForeignKey("questions.id"), nullable=False)
    student_answer = Column(Text, nullable=False)
    
    # LLM grading outputs
    llm_score = Column(Float)
    llm_feedback = Column(Text)
    graded_at = Column(DateTime)
    grading_model_name = Column(String)  # useful if different from exam model
    grading_temperature = Column(Float)
    
    # Relationships
    submission = relationship("Submission", back_populates="answers")
    question = relationship("Question", back_populates="answers")
    regrade = relationship("Regrade", back_populates="answer", uselist=False, cascade="all, delete-orphan")
    
    # Indexes
    __table_args__ = (
        Index("idx_answer_submission_question", "submission_id", "question_id", unique=True),
    )


class Regrade(Base):
    """Regrades table"""
    __tablename__ = "regrades"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    answer_id = Column(Integer, ForeignKey("answers.id"), nullable=False, unique=True)
    student_argument = Column(Text, nullable=False)  # why they think it should be different
    regrade_score = Column(Float)
    regrade_feedback = Column(Text)
    regraded_at = Column(DateTime)
    regrade_model_name = Column(String)
    regrade_temperature = Column(Float)
    
    # Relationships
    answer = relationship("Answer", back_populates="regrade")


class AuditEvent(Base):
    """Audit events table"""
    __tablename__ = "audit_events"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    actor_type = Column(String, nullable=False)  # 'instructor' | 'student' | 'system'
    actor_id = Column(Integer)  # nullable when system
    action = Column(String, nullable=False)  # e.g., 'CREATE_EXAM', 'GRADE_ANSWER'
    entity_type = Column(String)  # e.g., 'exam','submission','answer'
    entity_id = Column(Integer)
    details = Column(Text)  # JSON-ish string if you want
    created_at = Column(DateTime, nullable=False, default=utc_now, server_default=func.now())
